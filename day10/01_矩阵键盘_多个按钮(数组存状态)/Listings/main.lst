C51 COMPILER V9.60.7.0   MAIN                                                              07/04/2024 23:05:54 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: D:\AppData\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listi
                    -ngs\main.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          #include "Config.h"
   2          #include "GPIO.h"
   3          #include "UART.h"
   4          #include "Delay.h"
   5          #include "Switch.h"
   6          #include "NVIC.h"
   7          
   8          #define Row1 P34
   9          #define Row2 P35
  10          #define Row3 P40
  11          #define Row4 P41
  12          #define COL1 P03
  13          #define COL2 P06
  14          #define COL3 P07
  15          #define COL4 P17
  16          
  17          
  18          //将矩阵键盘的相关引脚全部初始化为准双向
  19          void GPIO_config() {
  20   1          P0_MODE_IO_PU(GPIO_Pin_3 | GPIO_Pin_6 | GPIO_Pin_7);
  21   1          P1_MODE_IO_PU(GPIO_Pin_7);
  22   1          P3_MODE_IO_PU(GPIO_Pin_4 | GPIO_Pin_5);
  23   1          P4_MODE_IO_PU(GPIO_Pin_0 | GPIO_Pin_1);
  24   1      }
  25          
  26          void UART_config(void) {
  27   1          // >>> 记得添加 NVIC.c, UART.c, UART_Isr.c <<<
  28   1          COMx_InitDefine COMx_InitStructure;                    //结构定义
  29   1          COMx_InitStructure.UART_Mode = UART_8bit_BRTx;    //模式, UART_ShiftRight,UART_8bit_BRTx,UART_9bit,U
             -ART_9bit_BRTx
  30   1          COMx_InitStructure.UART_BRT_Use = BRT_Timer1;            //选择波特率发生器, BRT_Timer1, BRT_T
             -imer2 (注意: 串口2固定使用BRT_Timer2)
  31   1          COMx_InitStructure.UART_BaudRate = 115200ul;            //波特率, 一般 110 ~ 115200
  32   1          COMx_InitStructure.UART_RxEnable = ENABLE;                //接收允许,   ENABLE或DISABLE
  33   1          COMx_InitStructure.BaudRateDouble = DISABLE;            //波特率加倍, ENABLE或DISABLE
  34   1          UART_Configuration(UART1, &COMx_InitStructure);        //初始化串口1 UART1,UART2,UART3,UART4
  35   1      
  36   1          NVIC_UART1_Init(ENABLE,
  37   1                          Priority_1);        //中断使能, ENABLE/DISABLE; 优先级(低到高) Priority_0,Pr
             -iority_1,Priority_2,Priority_3
  38   1          UART1_SW(UART1_SW_P30_P31);        // 引脚选择, UART1_SW_P30_P31,UART1_SW_P36_P37,UART1_SW_P16_P17
             -,UART1_SW_P43_P44
  39   1      }
  40          
  41          //按下为低电平，抬起为高电平
  42          #define DOWN 0
  43          #define UP 1
  44          
  45          //记录按钮前一刻的状态
  46          u8 key_last_state[16] = {
  47                  UP, UP, UP, UP,
  48                  UP, UP, UP, UP,
  49                  UP, UP, UP, UP,
  50                  UP, UP, UP, UP
C51 COMPILER V9.60.7.0   MAIN                                                              07/04/2024 23:05:54 PAGE 2   

  51          };
  52          
  53          //根据传入的行id改变行的电平状态，以进入监听状态
  54          void chang_row_state(u8 row_id) {
  55   1          Row1 = (row_id == 0 ? 0 : 1);
  56   1          Row2 = (row_id == 1 ? 0 : 1);
  57   1          Row3 = (row_id == 2 ? 0 : 1);
  58   1          Row4 = (row_id == 3 ? 0 : 1);
  59   1      }
  60          
  61          //根据列id获取列的电平状态
  62          u8 col_id_get_state(u8 col_id) {
  63   1          switch (col_id) {
  64   2              case 0:
  65   2                  return COL1;
  66   2                  break;
  67   2              case 1:
  68   2                  return COL2;
  69   2                  break;
  70   2              case 2:
  71   2                  return COL3;
  72   2                  break;
  73   2              case 3:
  74   2                  return COL4;
  75   2                  break;
  76   2              default:
  77   2                  return 0;
  78   2                  break;
  79   2          }
  80   1      }
  81          //按键之前的状态是否为抬起
  82          #define IS_KEY_UP(row_id, col_id) key_last_state[(4 * row_id) + col_id] == UP
  83          //按键之前的状态是否为按下
  84          #define IS_KEY_DOWN(row_id, col_id) key_last_state[(4 * row_id) + col_id] == DOWN
  85          //修改按键当前状态为按下
  86          #define SET_KEY_DOWN(row_id, col_id) key_last_state[(4 * row_id) + col_id] = DOWN
  87          //修改按键当前状态为抬起
  88          #define SET_KEY_UP(row_id, col_id) key_last_state[(4 * row_id) + col_id] = UP
  89          
  90          
  91          void key_scan() {
  92   1          u8 row_id;//行号ID
  93   1          u8 col_id;//列号ID
  94   1      
  95   1          //循环行
  96   1          for (row_id = 0; row_id < 4; row_id++) {
  97   2              //循环到哪一行，哪一行就切换成低电平(进入监听)
  98   2              chang_row_state(row_id);
  99   2              //遍历每一列的电平状态，以判断是否按下
 100   2              for (col_id = 0; col_id < 4; col_id++) {
 101   3                  //按键按下
 102   3                  if (col_id_get_state(col_id) == DOWN && IS_KEY_UP(row_id, col_id)) {
 103   4                      printf("ROW:%d COL：%d of Key Down\n", (int) row_id, (int) col_id);
 104   4                      //更新状态
 105   4                      SET_KEY_DOWN(row_id, col_id);
 106   4                  } else if (col_id_get_state(col_id) == UP && IS_KEY_DOWN(row_id, col_id)) {
 107   4                      printf("ROW:%d COL：%d of Key Up\n", (int) row_id, (int) col_id);
 108   4                      SET_KEY_UP(row_id, col_id);
 109   4                  }
 110   3              }
 111   2      
 112   2          }
C51 COMPILER V9.60.7.0   MAIN                                                              07/04/2024 23:05:54 PAGE 3   

 113   1      }
 114          
 115          int main() {
 116   1          GPIO_config();
 117   1          UART_config();
 118   1      
 119   1          EA = 1;
 120   1          while (1) {
 121   2              key_scan();
 122   2              //每25ms监听一次按键的变化
 123   2              delay_ms(25);
 124   2          }
 125   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    307    ----
   CONSTANT SIZE    =     56    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     16      11
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)

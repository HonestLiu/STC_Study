C51 COMPILER V9.60.7.0   MAIN                                                              07/05/2024 08:14:50 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: D:\AppData\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listi
                    -ngs\main.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          #include "Config.h"
   2          #include "GPIO.h"
   3          #include "UART.h"
   4          #include "Delay.h"
   5          #include "Switch.h"
   6          #include "NVIC.h"
   7          
   8          #define Row1 P34
   9          #define Row2 P35
  10          #define Row3 P40
  11          #define Row4 P41
  12          #define COL1 P03
  13          #define COL2 P06
  14          #define COL3 P07
  15          #define COL4 P17
  16          
  17          
  18          //将矩阵键盘的相关引脚全部初始化为准双向
  19          void GPIO_config() {
  20   1          P0_MODE_IO_PU(GPIO_Pin_3 | GPIO_Pin_6 | GPIO_Pin_7);
  21   1          P1_MODE_IO_PU(GPIO_Pin_7);
  22   1          P3_MODE_IO_PU(GPIO_Pin_4 | GPIO_Pin_5);
  23   1          P4_MODE_IO_PU(GPIO_Pin_0 | GPIO_Pin_1);
  24   1      }
  25          
  26          void UART_config(void) {
  27   1          // >>> 记得添加 NVIC.c, UART.c, UART_Isr.c <<<
  28   1          COMx_InitDefine COMx_InitStructure;                    //结构定义
  29   1          COMx_InitStructure.UART_Mode = UART_8bit_BRTx;    //模式, UART_ShiftRight,UART_8bit_BRTx,UART_9bit,U
             -ART_9bit_BRTx
  30   1          COMx_InitStructure.UART_BRT_Use = BRT_Timer1;            //选择波特率发生器, BRT_Timer1, BRT_T
             -imer2 (注意: 串口2固定使用BRT_Timer2)
  31   1          COMx_InitStructure.UART_BaudRate = 115200ul;            //波特率, 一般 110 ~ 115200
  32   1          COMx_InitStructure.UART_RxEnable = ENABLE;                //接收允许,   ENABLE或DISABLE
  33   1          COMx_InitStructure.BaudRateDouble = DISABLE;            //波特率加倍, ENABLE或DISABLE
  34   1          UART_Configuration(UART1, &COMx_InitStructure);        //初始化串口1 UART1,UART2,UART3,UART4
  35   1      
  36   1          NVIC_UART1_Init(ENABLE,
  37   1                          Priority_1);        //中断使能, ENABLE/DISABLE; 优先级(低到高) Priority_0,Pr
             -iority_1,Priority_2,Priority_3
  38   1          UART1_SW(UART1_SW_P30_P31);        // 引脚选择, UART1_SW_P30_P31,UART1_SW_P36_P37,UART1_SW_P16_P17
             -,UART1_SW_P43_P44
  39   1      }
  40          
  41          //按下为低电平，抬起为高电平
  42          #define DOWN 0
  43          #define UP 1
  44          
  45          //记录按钮前一刻的状态
  46          /*u8 key_last_state[16] = {
  47                  UP, UP, UP, UP,
  48                  UP, UP, UP, UP,
  49                  UP, UP, UP, UP,
  50                  UP, UP, UP, UP
C51 COMPILER V9.60.7.0   MAIN                                                              07/05/2024 08:14:50 PAGE 2   

  51          };*/
  52          u16 key_last_state = 0xFFFF;
  53          
  54          //按键之前的状态是否为抬起
  55          #define IS_KEY_UP(row_id, col_id) (key_last_state & (1 << (4 * row_id + col_id))) > 0
  56          //按键之前的状态是否为按下
  57          #define IS_KEY_DOWN(row_id, col_id) (key_last_state & (1 << (4 * row_id + col_id))) == 0
  58          //修改按键当前状态为按下
  59          #define SET_KEY_DOWN(row_id, col_id) key_last_state &=~ (1 << (4 * row_id + col_id))
  60          //修改按键当前状态为抬起
  61          #define SET_KEY_UP(row_id, col_id) key_last_state |= (1 << (4 * row_id + col_id))
  62          
  63          
  64          //根据传入的行id改变行的电平状态，以进入监听状态
  65          void chang_row_state(u8 row_id) {
  66   1          Row1 = (row_id == 0 ? 0 : 1);
  67   1          Row2 = (row_id == 1 ? 0 : 1);
  68   1          Row3 = (row_id == 2 ? 0 : 1);
  69   1          Row4 = (row_id == 3 ? 0 : 1);
  70   1      }
  71          
  72          //根据列id获取列的电平状态
  73          u8 col_id_get_state(u8 col_id) {
  74   1          switch (col_id) {
  75   2              case 0:
  76   2                  return COL1;
  77   2                  break;
  78   2              case 1:
  79   2                  return COL2;
  80   2                  break;
  81   2              case 2:
  82   2                  return COL3;
  83   2                  break;
  84   2              case 3:
  85   2                  return COL4;
  86   2                  break;
  87   2              default:
  88   2                  return 0;
  89   2                  break;
  90   2          }
  91   1      }
  92          
  93          void key_scan() {
  94   1          u8 row_id;//行号ID
  95   1          u8 col_id;//列号ID
  96   1      
  97   1          //循环行
  98   1          for (row_id = 0; row_id < 4; row_id++) {
  99   2              //循环到哪一行，哪一行就切换成低电平(进入监听)
 100   2              chang_row_state(row_id);
 101   2              //遍历每一列的电平状态，以判断是否按下
 102   2              for (col_id = 0; col_id < 4; col_id++) {
 103   3                  //按键按下
 104   3                  if (col_id_get_state(col_id) == DOWN && IS_KEY_UP(row_id, col_id)) {
 105   4                      printf("ROW:%d COL：%d of Key Down\n", (int) row_id, (int) col_id);
 106   4                      //更新状态
 107   4                      SET_KEY_DOWN(row_id, col_id);
 108   4                  } else if (col_id_get_state(col_id) == UP && IS_KEY_DOWN(row_id, col_id)) {
 109   4                      printf("ROW:%d COL：%d of Key Up\n", (int) row_id, (int) col_id);
 110   4                      SET_KEY_UP(row_id, col_id);
 111   4                  }
 112   3              }
C51 COMPILER V9.60.7.0   MAIN                                                              07/05/2024 08:14:50 PAGE 3   

 113   2      
 114   2          }
 115   1      }
 116          
 117          int main() {
 118   1          GPIO_config();
 119   1          UART_config();
 120   1      
 121   1          EA = 1;
 122   1          while (1) {
 123   2              key_scan();
 124   2              //每25ms监听一次按键的变化
 125   2              delay_ms(25);
 126   2          }
 127   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    399    ----
   CONSTANT SIZE    =     56    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      2      11
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)

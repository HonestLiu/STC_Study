C51 COMPILER V9.60.7.0   DHT11                                                             07/03/2024 11:29:28 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE DHT11
OBJECT MODULE PLACED IN .\Objects\DHT11.obj
COMPILER INVOKED BY: D:\AppData\Keil_v5\C51\BIN\C51.EXE DHT11.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\List
                    -ings\DHT11.lst) TABS(2) OBJECT(.\Objects\DHT11.obj)

line level    source

   1          #include "DHT11.h"
   2          #include "GPIO.h"
   3          #include "Delay.h"
   4          
   5          // level 当前电平状态
   6          #define wait_level_change(level, min, max, description)                  \
   7              cnt = 0;                                                                \
   8              do {                                                                    \
   9                  delay_1us();                                                        \
  10                  cnt++;                                                              \
  11              } while(DHT11 == level);                                                  \
  12              if (cnt < min || cnt > max) {                                           \
  13                  printf("err: [%s] [%d]us 不满足!\n", description, cnt);              \
  14                  return -1;                                                          \
  15              }
  16          
  17          //延时1us的函数
  18          void delay_1us() {
  19   1          NOP10();
  20   1      }
  21          
  22          // 初始化GPIO-P46为准双向
  23          static void GPIO_config() {
  24   1          GPIO_InitTypeDef gpio_init_struct;
  25   1          gpio_init_struct.Mode = GPIO_PullUp;
  26   1          gpio_init_struct.Pin = GPIO_Pin_6;
  27   1          GPIO_Inilize(GPIO_P4, &gpio_init_struct);
  28   1      }
  29          
  30          void DHT11_init() {
  31   1          GPIO_config();
  32   1      }
  33          
  34          char on_read(u8 *dat) {
  35   1          u16 cnt = 0;
  36   1          char i = 0, j = 0;//用来遍历的变量
  37   1          /*1.主机起始信号拉低时间: 主机起始拉低DHT11引脚的电平*/
  38   1          DHT11 = 0;
  39   1          delay_ms(20);//保持低电平在一个典型值时长->20ms
  40   1          /*2.主机释放总线时间: 等待由高电平转换为低电平 时间范围[10,50](50是取了下
             -个状态的中间值，从而判断通信失败)*/
  41   1          DHT11 = 1;
  42   1          //计数统计，每1us计数一次，统计消耗的时间
  43   1          cnt = 0;
  44   1          do {
  45   2              delay_1us();
  46   2              cnt++;
  47   2          } while (DHT11 == 1 && cnt < 50);
  48   1          //根据统计消耗时间判断此阶段是否成功
  49   1          if (cnt < 10 || cnt > 35) {
  50   2              printf("主机释放时间超时\n");
  51   2              return -1;
  52   2          }
  53   1          /*3.响应低电平时间: 低电平时间 [78:88]*/
C51 COMPILER V9.60.7.0   DHT11                                                             07/03/2024 11:29:28 PAGE 2   

  54   1          wait_level_change(0, 78, 88, "响应低电平时间超时");
  55   1          /*4.响应高电平时间: 高电平时间 [80:92]*/
  56   1          wait_level_change(1, 80, 92, "响应高电平时间超时");
  57   1          /*5.解析接收到的电平，根据高低电平时长区分0或1*/
  58   1          for (i = 0; i < 5; i++) {//需要读5个byte,每读8个bit循环一次
  59   2              for (j = 7; j >= 0; j--) {//每次循环读8个bit(数据写入必须从右往左写入⚠)
  60   3                  u8 bit_dat;
  61   3                  //统计0、1的数据低电平时间
  62   3                  wait_level_change(0, 48, 58, "data低电平时间");
  63   3                  //统计高电平时间，用以判断是0还是1
  64   3                  wait_level_change(1, 23, 74, "data高电平时间");
  65   3                  //判断高低电平，然后写入到存储数组中(取中间值47,小于47的为0,高于47
             -为1)
  66   3                  bit_dat = (cnt >= 48 ? 1 : 0);
  67   3                  dat[i] |= (bit_dat << j);//位移写入该bit在该byte的对应位置
  68   3              }
  69   2          }
  70   1      
  71   1          //校验数据；校验位(第4个数据)＝湿度高位+湿度低位+温度高位+温度低位
  72   1          if ((dat[0] + dat[1] + dat[2] + dat[3]) != dat[4]) {
  73   2              printf("Data validation failure!!");//数据校验失败
  74   2              return -1;
  75   2          }
  76   1          //成功返回0，实际对数据的处理在main函数中进行
  77   1          return 0;
  78   1      }
  79          
  80          
  81          char DHT11_get_info(float *humidity, float *temperature) {
  82   1          char ret = -1;
  83   1          u8 dat[5] = {0};    // 准备5个字节的容器,接收结果
  84   1      
  85   1          ret = on_read(dat);
  86   1          if (ret < 0) {    //数据校验失败
  87   2              return -1;
  88   2          }
  89   1          /*1.计算湿度*/
  90   1          *humidity = (int) dat[0];
  91   1          /*2.计算温度*/
  92   1          // 温度值: 温度高位的后7bit + 温度低位 * 0.1
  93   1          *temperature = dat[2] + ((dat[3] & 0x7F) * 0.1);
  94   1          // 温度的正负: 取温度高位的最高位
  95   1          if ((dat[3] & 0x80) > 0) {//为1则为负数
  96   2              //对获取的温度值进行取反、
  97   2              *temperature = -*temperature;
  98   2          }
  99   1      
 100   1          return 0;
 101   1      
 102   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    675    ----
   CONSTANT SIZE    =    182    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      21
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)

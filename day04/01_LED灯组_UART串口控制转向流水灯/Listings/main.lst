C51 COMPILER V9.60.7.0   MAIN                                                              06/23/2024 13:04:03 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\main
                    -.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          #include "Config.h"
   2          #include "GPIO.h"
   3          #include "Delay.h"
   4          #include "Timer.h"
   5          #include "UART.h"
   6          #include "Switch.h"
   7          #include "NVIC.h"
   8          
   9          #define LED_SW P45
  10          
  11          #define LED4 P14
  12          #define LED3 P15
  13          #define LED8 P20
  14          #define LED7 P21
  15          #define LED6 P22
  16          #define LED5 P23
  17          #define LED2 P26
  18          #define LED1 P27
  19          
  20          #define HIGH 1
  21          #define LOW 0
  22          
  23          /*³õÊ¼»¯GPIO*/
  24          void gpio_init(void)
  25          {
  26   1        /* UART¶Ë¿Ú */
  27   1        GPIO_InitTypeDef gpio_config;
  28   1        gpio_config.Pin = GPIO_Pin_0 | GPIO_Pin_1;
  29   1        gpio_config.Mode = GPIO_PullUp;
  30   1        GPIO_Inilize(GPIO_P3, &gpio_config);
  31   1      
  32   1        /* LED¶Ë¿Ú */
  33   1        gpio_config.Pin = GPIO_Pin_4 | GPIO_Pin_5;
  34   1        GPIO_Inilize(GPIO_P1, &gpio_config);
  35   1      
  36   1        gpio_config.Pin = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3 | GPIO_Pin_6 | GPIO_Pin_7;
  37   1        GPIO_Inilize(GPIO_P2, &gpio_config);
  38   1        
  39   1        /* ³õÊ¼»¯×Ü¿ª¹Ø-SW */
  40   1        gpio_config.Pin = GPIO_Pin_5;
  41   1        gpio_config.Mode = GPIO_OUT_PP;
  42   1        GPIO_Inilize(GPIO_P4, &gpio_config);
  43   1      
  44   1      }
  45          
  46          /*³õÊ¼»¯UART*/
  47          void uart_init(void)
  48          {
  49   1        // >>> ¼ÇµÃÌí¼Ó NVIC.c, UART.c, UART_Isr.c <<<
  50   1        COMx_InitDefine COMx_InitStructure;       // ½á¹¹¶¨Òå
  51   1        COMx_InitStructure.UART_Mode = UART_8bit_BRTx;  // Ä£Ê½, UART_ShiftRight,UART_8bit_BRTx,UART_9bit,UART_9bi
             -t_BRTx
  52   1        COMx_InitStructure.UART_BRT_Use = BRT_Timer1; // Ñ¡Ôñ²¨ÌØÂÊ·¢ÉúÆ÷, BRT_Timer1, BRT_Timer2 (×¢Òâ: ´®¿Ú2¹Ì¶
             -¨Ê¹ÓÃBRT_Timer2)
C51 COMPILER V9.60.7.0   MAIN                                                              06/23/2024 13:04:03 PAGE 2   

  53   1        COMx_InitStructure.UART_BaudRate = 115200ul;  // ²¨ÌØÂÊ, Ò»°ã 110 ~ 115200
  54   1        COMx_InitStructure.UART_RxEnable = ENABLE;    // ½ÓÊÕÔÊÐí,   ENABLE»òDISABLE
  55   1        COMx_InitStructure.BaudRateDouble = DISABLE;  // ²¨ÌØÂÊ¼Ó±¶, ENABLE»òDISABLE
  56   1        UART_Configuration(UART1, &COMx_InitStructure); // ³õÊ¼»¯´®¿Ú1 UART1,UART2,UART3,UART4
  57   1      
  58   1        NVIC_UART1_Init(ENABLE, Priority_1); // ÖÐ¶ÏÊ¹ÄÜ, ENABLE/DISABLE; ÓÅÏÈ¼¶(µÍµ½¸ß) Priority_0,Priority_1,Pr
             -iority_2,Priority_3
  59   1        UART1_SW(UART1_SW_P30_P31);      // Òý½ÅÑ¡Ôñ, UART1_SW_P30_P31,UART1_SW_P36_P37,UART1_SW_P16_P17,UART1_SW_P
             -43_P44
  60   1      }
  61          
  62          /* ³õÊ¼»¯¶¨Ê±Æ÷ */
  63          void timer_init(void)
  64          {
  65   1      
  66   1        TIM_InitTypeDef TIM_InitStructure; // ½á¹¹¶¨Òå
  67   1        // ¶¨Ê±Æ÷0×ö16Î»×Ô¶¯ÖØ×°, ÖÐ¶ÏÆµÂÊÎª1000HZ
  68   1        TIM_InitStructure.TIM_Mode = TIM_16BitAutoReload;       // Ö¸¶¨¹¤×÷Ä£Ê½,   TIM_16BitAutoReload,TIM_16Bit,TI
             -M_8BitAutoReload,TIM_16BitAutoReloadNoMask
  69   1        TIM_InitStructure.TIM_ClkSource = TIM_CLOCK_1T;         // Ö¸¶¨Ê±ÖÓÔ´,     TIM_CLOCK_1T,TIM_CLOCK_12T,TIM_CL
             -OCK_Ext
  70   1        TIM_InitStructure.TIM_ClkOut = DISABLE;             // ÊÇ·ñÊä³ö¸ßËÙÂö³å, ENABLE»òDISABLE
  71   1        TIM_InitStructure.TIM_Value = 65536UL - (MAIN_Fosc / 1000UL); // ³õÖµ,
  72   1        TIM_InitStructure.TIM_Run = ENABLE;               // ÊÇ·ñ³õÊ¼»¯ºóÆô¶¯¶¨Ê±Æ÷, ENABLE»òDISABLE
  73   1        Timer_Inilize(Timer0, &TIM_InitStructure);            // ³õÊ¼»¯Timer0   Timer0,Timer1,Timer2,Timer3,Timer4
  74   1        NVIC_Timer0_Init(ENABLE, Priority_0);             // ÖÐ¶ÏÊ¹ÄÜ, ENABLE/DISABLE; ÓÅÏÈ¼¶(µÍµ½¸ß) Priority_0,Prior
             -ity_1,Priority_2,Priority_3
  75   1      }
  76          
  77          // ¶¨Ê±Æ÷ÖÐ¶Ïº¯Êý
  78          // ¹¦ÄÜ: ÅÐ¶ÏÊÇ·ñ½ÓÊÕµ½Êý¾Ý£¬´Ë²Ù×÷½ÏºÄÊ±£¬ÐèÒª½«¸´ÔÓµÄÂß¼­·ÖÀë³öÈ¥
  79          
  80          u8 tmp = 0x02; // ´æ´¢´®¿ÚÊý¾ÝµÄ±äÁ¿£¬0:×ó×ªÏòµÆ 1:ÓÒ×ªÏòµÆ
  81          void time_call(void)
  82          {
  83   1        if (COM1.RX_TimeOut > 0)
  84   1        {
  85   2          // ³¬Ê±¼ÆÊý
  86   2          if (--COM1.RX_TimeOut == 0)
  87   2          {
  88   3            if (COM1.RX_Cnt > 0)
  89   3            {
  90   4              // ½«È«¾Ö×´Ì¬±äÁ¿±ê¼ÇÎª¶ÔÓ¦µÄ×´Ì¬
  91   4              u8 dat = RX1_Buffer[0];
  92   4              tmp = dat;
  93   4            }
  94   3            COM1.RX_Cnt = 0;
  95   3          }
  96   2        }
  97   1      
  98   1      }
  99          
 100          // ÓÒ×ªLED¿ØÖÆº¯Êý
 101          void turn_right(void)
 102          {
 103   1        char i;
 104   1        for (i = 0; i < 8; i++)
 105   1        {
 106   2          if (i == 0)
 107   2            LED1 = 0;
 108   2          if (i == 1)
 109   2            LED2 = 0;
C51 COMPILER V9.60.7.0   MAIN                                                              06/23/2024 13:04:03 PAGE 3   

 110   2          if (i == 2)
 111   2            LED3 = 0;
 112   2          if (i == 3)
 113   2            LED4 = 0;
 114   2          if (i == 4)
 115   2            LED5 = 0;
 116   2          if (i == 5)
 117   2            LED6 = 0;
 118   2          if (i == 6)
 119   2            LED7 = 0;
 120   2          if (i == 7)
 121   2            LED8 = 0;
 122   2          delay_ms(100);
 123   2        }
 124   1      
 125   1        // ¹Ø±ÕËùÓÐLED
 126   1        delay_ms(200);
 127   1        LED1 = LED2 = LED3 = LED4 = LED5 = LED6 = LED7 = LED8 = 1;
 128   1      }
 129          
 130          void turn_left(void)
 131          {
 132   1        char i;
 133   1        for (i = 7; i >= 0; i--)
 134   1        {
 135   2          if (i == 0)
 136   2            LED1 = 0;
 137   2          if (i == 1)
 138   2            LED2 = 0;
 139   2          if (i == 2)
 140   2            LED3 = 0;
 141   2          if (i == 3)
 142   2            LED4 = 0;
 143   2          if (i == 4)
 144   2            LED5 = 0;
 145   2          if (i == 5)
 146   2            LED6 = 0;
 147   2          if (i == 6)
 148   2            LED7 = 0;
 149   2          if (i == 7)
 150   2            LED8 = 0;
 151   2          delay_ms(100);
 152   2        }
 153   1        // ¹Ø±ÕËùÓÐLED
 154   1        delay_ms(200);
 155   1        LED1 = LED2 = LED3 = LED4 = LED5 = LED6 = LED7 = LED8 = 1;
 156   1      }
 157          
 158          
 159          int main(void)
 160          {
 161   1        gpio_init();
 162   1        uart_init();
 163   1        timer_init();
 164   1      
 165   1        // ¿ªÆôÈ«¾ÖÖÐ¶Ï
 166   1        EA = 1;
 167   1        // ¿ªÆôLED×Ü¿ª¹Ø
 168   1        LED_SW = 0;
 169   1      
 170   1        // Ä¬ÈÏ¹Ø±ÕËùÓÐLED
 171   1        LED1 = LED2 = LED3 = LED4 = LED5 = LED6 = LED7 = LED8 = 1;
C51 COMPILER V9.60.7.0   MAIN                                                              06/23/2024 13:04:03 PAGE 4   

 172   1      
 173   1        while (1)
 174   1        {
 175   2          // ´¦ÀíLEDµÄÂß¼­
 176   2          delay_ms(10);
 177   2          if (tmp == 0x00) // ×ó×ª
 178   2          {
 179   3            // ×óÁ÷Ë®µÆ
 180   3            turn_left();
 181   3      
 182   3            // ´¦ÀíÍêÂß¼­¸´Î»×´Ì¬Öµ
 183   3            tmp = 0x02;
 184   3          }
 185   2          else if (tmp == 0x01) // ÓÒ×ª
 186   2          {
 187   3            // ÓÒÁ÷Ë®µÆ
 188   3            turn_right();
 189   3      
 190   3            // ´¦ÀíÍêÂß¼­¸´Î»×´Ì¬Öµ
 191   3            tmp = 0x02;
 192   3          }
 193   2        }
 194   1        
 195   1      
 196   1      
 197   1        
 198   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    420    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      1      21
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)

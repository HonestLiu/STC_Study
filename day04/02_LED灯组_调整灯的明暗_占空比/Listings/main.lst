C51 COMPILER V9.60.7.0   MAIN                                                              06/23/2024 11:59:00 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\main
                    -.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          #include "Config.h"
   2          #include "GPIO.h"
   3          #include "Delay.h"
   4          #include "Timer.h"
   5          #include "UART.h"
   6          #include "Switch.h"
   7          #include "NVIC.h"
   8          
   9          #define LED_SW P45
  10          
  11          #define LED4 P14
  12          #define LED3 P15
  13          #define LED8 P20
  14          #define LED7 P21
  15          #define LED6 P22
  16          #define LED5 P23
  17          #define LED2 P26
  18          #define LED1 P27
  19          
  20          #define HIGH 1
  21          #define LOW 0
  22          
  23          /*初始化GPIO*/
  24          void gpio_init(void)
  25          {
  26   1        /* UART端口 */
  27   1        GPIO_InitTypeDef gpio_config;
  28   1        gpio_config.Pin = GPIO_Pin_0 | GPIO_Pin_1;
  29   1        gpio_config.Mode = GPIO_PullUp;
  30   1        GPIO_Inilize(GPIO_P3, &gpio_config);
  31   1        
  32   1        /* LED端口 */
  33   1        gpio_config.Pin = GPIO_Pin_4 | GPIO_Pin_5;
  34   1        GPIO_Inilize(GPIO_P1, &gpio_config);
  35   1      
  36   1        gpio_config.Pin = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3 | GPIO_Pin_6 | GPIO_Pin_7;
  37   1        GPIO_Inilize(GPIO_P2, &gpio_config);
  38   1      
  39   1        /* 初始化总开关-SW */
  40   1        gpio_config.Pin = GPIO_Pin_5;
  41   1        gpio_config.Mode = GPIO_OUT_PP;//推挽输出模式
  42   1        GPIO_Inilize(GPIO_P4, &gpio_config);
  43   1      }
  44          
  45          /*初始化UART*/
  46          void uart_init(void)
  47          {
  48   1          COMx_InitDefine   COMx_InitStructure;         //结构定义
  49   1          COMx_InitStructure.UART_Mode      = UART_8bit_BRTx; //模式, UART_ShiftRight,UART_8bit_BRTx,UART_9bit,U
             -ART_9bit_BRTx
  50   1          COMx_InitStructure.UART_BRT_Use   = BRT_Timer1;     //选择波特率发生器, BRT_Timer1, BRT_Timer2 (注意: 串
             -口2固定使用BRT_Timer2)
  51   1          COMx_InitStructure.UART_BaudRate  = 115200ul;     //波特率, 一般 110 ~ 115200
  52   1          COMx_InitStructure.UART_RxEnable  = ENABLE;       //接收允许,   ENABLE或DISABLE
C51 COMPILER V9.60.7.0   MAIN                                                              06/23/2024 11:59:00 PAGE 2   

  53   1          COMx_InitStructure.BaudRateDouble = DISABLE;      //波特率加倍, ENABLE或DISABLE
  54   1          UART_Configuration(UART1, &COMx_InitStructure);   //初始化串口1 UART1,UART2,UART3,UART4
  55   1      
  56   1          NVIC_UART1_Init(ENABLE,Priority_1);   //中断使能, ENABLE/DISABLE; 优先级(低到高) Priority_0,Priority_1,
             -Priority_2,Priority_3
  57   1          UART1_SW(UART1_SW_P30_P31);   // 引脚选择, UART1_SW_P30_P31,UART1_SW_P36_P37,UART1_SW_P16_P17,UART1_SW_
             -P43_P44
  58   1      }
  59          
  60          /* 初始化定时器 */
  61          void timer_init(void)
  62          {
  63   1      
  64   1        TIM_InitTypeDef TIM_InitStructure; // 结构定义
  65   1        // 定时器0做16位自动重装, 中断频率为1000HZ
  66   1        TIM_InitStructure.TIM_Mode = TIM_16BitAutoReload;        // 指定工作模式,   TIM_16BitAutoReload,TIM_16Bit,T
             -IM_8BitAutoReload,TIM_16BitAutoReloadNoMask
  67   1        TIM_InitStructure.TIM_ClkSource = TIM_CLOCK_1T;          // 指定时钟源,     TIM_CLOCK_1T,TIM_CLOCK_12T,TIM_C
             -LOCK_Ext
  68   1        TIM_InitStructure.TIM_ClkOut = DISABLE;              // 是否输出高速脉冲, ENABLE或DISABLE
  69   1        TIM_InitStructure.TIM_Value = 65536UL - (MAIN_Fosc / 1000UL); // 初值,
  70   1        TIM_InitStructure.TIM_Run = ENABLE;                // 是否初始化后启动定时器, ENABLE或DISABLE
  71   1        Timer_Inilize(Timer0, &TIM_InitStructure);             // 初始化Timer0    Timer0,Timer1,Timer2,Timer3,Timer4
  72   1        NVIC_Timer0_Init(ENABLE, Priority_0);              // 中断使能, ENABLE/DISABLE; 优先级(低到高) Priority_0,Prio
             -rity_1,Priority_2,Priority_3
  73   1      }
  74          
  75          // 定时器中断函数
  76          // 功能: 设置LED的亮度
  77          #define FREQ 100        // 100Hz,频率，即每秒多少了周期
  78          #define PERIOD (1000 / FREQ) // 10ms,每个周期的时间，周期 / 频率(周期需要根据实际初始化定时器的值而定)
  79          int counter = 0;        // 计数器，每次对LED的操作都会++
  80          float duty = 0.2f;        // 占空比，即1周期内高电平持续的比例
  81          
  82          void time_call(void)
  83          {
  84   1        if (counter < (duty * PERIOD)) // 占空比 * 周期时间 = 高电平的时间
  85   1        {
  86   2          LED1 = 0; // 点亮LED
  87   2        }
  88   1        else
  89   1        {
  90   2          LED1 = 1; // 关闭LED
  91   2        }
  92   1      
  93   1        if (++counter == PERIOD) // 当期操作次数等于一个周期会操作的LED次数时，会被清零
  94   1        {
  95   2          counter = 0;
  96   2        }
  97   1      }
  98          
  99          
 100          
 101          
 102          // 串口亮度调节回调函数
 103          void on_uart_recv(void)
 104          {
 105   1        /*
 106   1        收到0x00降低亮度
 107   1        收到0x01提高亮度
 108   1         */
 109   1        u8 dat = RX1_Buffer[0];
C51 COMPILER V9.60.7.0   MAIN                                                              06/23/2024 11:59:00 PAGE 3   

 110   1        if (dat == 0) // 更暗
 111   1        {
 112   2          duty -= 0.02; // 每次减少2%
 113   2          // 当它调整为0时，不继续向下减，维持原状
 114   2          if (duty < 0.0)
 115   2          {
 116   3            duty = 0.0f;
 117   3          }
 118   2        }
 119   1        else if (dat == 1)//更亮
 120   1        {
 121   2          duty += 0.02; // 每次增加2%
 122   2          // 当duty的值大于1时，维持原状不变
 123   2          if (duty > 1.0)
 124   2          {
 125   3            duty = 1.0f;
 126   3          }
 127   2        }
 128   1        printf("duty: %.2f\n", duty);
 129   1      }
 130          
 131          //void on_uart_recv(){
 132          
 133          //    // 收到0x00降低亮度
 134          //    // 收到0x01提升亮度
 135          //    u8 dat = RX1_Buffer[0];
 136          //  
 137          //    if(dat == 0){ // 更暗
 138          //      duty -= 0.02;
 139          //      if (duty < 0.0) duty = 0.0f;
 140          //    }else if(dat == 1){
 141          //      duty += 0.02;
 142          //      if (duty > 1.0) duty = 1.0f;
 143          //    }
 144          //    printf("duty: %.2f\n", duty);
 145          //}
 146          
 147          
 148          int main()
 149          {
 150   1        gpio_init();
 151   1        uart_init();
 152   1        timer_init();
 153   1      
 154   1        // 开启全局中断
 155   1        EA = 1;
 156   1        // 开启LED总开关
 157   1        LED_SW = 0;
 158   1      
 159   1        // 默认关闭所有LED
 160   1        //LED1 = LED2 = LED3 = LED4 = LED5 = LED6 = LED7 = LED8 = 1;
 161   1        LED1 = 0;
 162   1      
 163   1        while (1)
 164   1        {
 165   2          delay_ms(10); // 延时10ms
 166   2      
 167   2          if (COM1.RX_TimeOut > 0)
 168   2          {
 169   3            // 超时计数
 170   3            if (--COM1.RX_TimeOut == 0)
 171   3            {
C51 COMPILER V9.60.7.0   MAIN                                                              06/23/2024 11:59:00 PAGE 4   

 172   4              if (COM1.RX_Cnt > 0)
 173   4              {
 174   5                on_uart_recv();
 175   5              }
 176   4              COM1.RX_Cnt = 0;
 177   4            }
 178   3          }
 179   2        }
 180   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    416    ----
   CONSTANT SIZE    =     12    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      6      19
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)

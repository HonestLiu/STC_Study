C51 COMPILER V9.60.7.0   MAIN                                                              06/13/2024 16:13:04 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: D:\AppData\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listi
                    -ngs\main.lst) OBJECT(.\Objects\main.obj)

line level    source

   1          #include "Config.h"
   2          #include "GPIO.h"
   3          #include "UART.h"
   4          #include "NVIC.h"
   5          #include "Delay.h"
   6          #include "Switch.h"
   7          
   8          /**
   9           * @author HonestLiu
  10           * @version 1.0
  11           * @Description: 串口通讯测试，通过UART1接收数据，然后通过UART4发送出去
  12           * @note UART1引脚: RXD(P3.0)和TXD(P3.1) UART2引脚:RXD(P5.2)和TXD(P5.3),这是一个通用的代码
             -可以同时烧写到两块实验板上，其会判断不同端口进而执行不同逻辑
  13           * @since 2024/6/13
  14           */
  15          
  16          // 配置GPIO
  17          void gpio_config(void)
  18          {
  19   1      
  20   1          /* UART1引脚初始化 */
  21   1          GPIO_InitTypeDef gpioConfigStruct;
  22   1          gpioConfigStruct.Pin = GPIO_Pin_0 | GPIO_Pin_1; // 配置引脚0和1
  23   1          gpioConfigStruct.Mode = GPIO_OUT_PP;            // 设置为推挽输出模式
  24   1          GPIO_Inilize(GPIO_P3, &gpioConfigStruct);
  25   1      
  26   1          /* UART2引脚初始化 */
  27   1          gpioConfigStruct.Pin = GPIO_Pin_2 | GPIO_Pin_3; // 配置引脚0和1
  28   1          gpioConfigStruct.Mode = GPIO_OUT_PP;            // 设置为推挽输出模式
  29   1          GPIO_Inilize(GPIO_P5, &gpioConfigStruct);
  30   1      }
  31          
  32          // 配置NVIC
  33          void nvic_config(void)
  34          {
  35   1          COMx_InitDefine COMx_InitStructure; // 结构定义
  36   1      
  37   1          COMx_InitStructure.UART_Mode = UART_8bit_BRTx;  // 模式, UART_ShiftRight,UART_8bit_BRTx,UART_9bit,UA
             -RT_9bit_BRTx
  38   1          COMx_InitStructure.UART_BRT_Use = BRT_Timer1;   // 选择波特率发生器, BRT_Timer1, BRT_Timer2 (
             -意: 串口2固定使用BRT_Timer2)
  39   1          COMx_InitStructure.UART_BaudRate = 115200ul;    // 波特率, 一般 110 ~ 115200
  40   1          COMx_InitStructure.UART_RxEnable = ENABLE;      // 接收允许,   ENABLE或DISABLE
  41   1          COMx_InitStructure.BaudRateDouble = DISABLE;    // 波特率加倍, ENABLE或DISABLE
  42   1          UART_Configuration(UART1, &COMx_InitStructure); // 初始化串口1 UART1,UART2,UART3,UART4
  43   1          UART_Configuration(UART4, &COMx_InitStructure); // 初始化串口4(如果没高亮记得去打开相
             -的宏)
  44   1          NVIC_UART1_Init(ENABLE, Priority_1);            // 中断使能UART1, ENABLE/DISABLE; 优先级(低到
             -高) Priority_0,Priority_1,Priority_2,Priority_3
  45   1          NVIC_UART4_Init(ENABLE, Priority_1);            // 中断使能UART4
  46   1      
  47   1          // 设置UART1和UART4的引脚
  48   1          UART1_SW(UART1_SW_P30_P31); // RXD(P3.0)和TXD(P3.1)
  49   1          UART4_SW(UART4_SW_P52_P53); // RXD(P5.2)和TXD(P5.3)
C51 COMPILER V9.60.7.0   MAIN                                                              06/13/2024 16:13:04 PAGE 2   

  50   1      }
  51          
  52          // 数据读取发送(回塞)函数-UART1
  53          // 接收到数据发送给另一块板子
  54          void backPlug01(void)
  55          {
  56   1          u8 i;
  57   1          u8 dat;
  58   1          // 按照读取字节的字节数变量缓冲区获取数据，并将获取的数据发送回去
  59   1          for (i = 0; i < COM1.RX_Cnt; i++)
  60   1          {
  61   2              dat = RX1_Buffer[i];
  62   2              TX4_write2buff(dat); // 将收到的数据通过串口4发送出去
  63   2          }
  64   1      }
  65          
  66          // 数据读取发送(回塞)函数-UART4
  67          // 接收到数据发送给PC
  68          void backPlug04(void)
  69          {
  70   1          u8 i;
  71   1          u8 dat;
  72   1          // 按照读取字节的字节数变量缓冲区获取数据，并将获取的数据发送回去
  73   1          for (i = 0; i < COM4.RX_Cnt; i++)
  74   1          {
  75   2              dat = RX4_Buffer[i];
  76   2              TX1_write2buff(dat); // 将收到的数据通过串口1发送出去,发送给PC
  77   2          }
  78   1      }
  79          
  80          int main(void)
  81          {
  82   1          // 初始化GPIO
  83   1          gpio_config();
  84   1          // 初始化NVIC
  85   1          nvic_config();
  86   1          // 开启中断
  87   1          EA = 1;
  88   1      
  89   1          while (1)
  90   1          {
  91   2              /* UART1收到数据的处理逻辑 */
  92   2              if ((COM1.RX_TimeOut > 0) && (--COM1.RX_TimeOut == 0))
  93   2              {
  94   3                  // 接收到的字节数>0,证明确实是收到数据了
  95   3                  if (COM1.RX_Cnt > 0)
  96   3                  {
  97   4                      // 调用数据读取函数读取获取到的数据
  98   4                      backPlug01();
  99   4                  }
 100   3                  // 读取完数据，将记录接收数据字节的变量置0
 101   3                  COM1.RX_Cnt = 0;
 102   3              }
 103   2      
 104   2              /* UART4收到数据的处理逻辑 */
 105   2              if ((COM4.RX_TimeOut > 0) && (--COM4.RX_TimeOut == 0))
 106   2              {
 107   3                  if (COM4.RX_Cnt > 0)
 108   3                  {
 109   4                      backPlug04();
 110   4                  }
 111   3                  COM4.RX_Cnt = 0;
C51 COMPILER V9.60.7.0   MAIN                                                              06/13/2024 16:13:04 PAGE 3   

 112   3              }
 113   2      
 114   2              // 延时10ms,避免频繁读取数据
 115   2              delay_ms(10);
 116   2          }
 117   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    232    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      15
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
